import glob
import natsort
import copy, os

generated_dir_path = '../Sources/DeclarativeCoreAnimation/Generated/CoreAnimation/merged/wrap'

header = '''
// Generated file
// DO NOT EDIT THIS FILE

#if canImport(QuartzCore)
import QuartzCore
'''

def get_type_name(path: str) -> str:
    return path.split('/')[-1].split('+')[0]

def get_path(type: str, paths: list[str])-> str:
    for path in paths:
        if type == get_type_name(path):
            return path
    return None

def get_text(path: str)->str:
    f = open(path, 'r')
    text = f.read()
    f.close()
    return text

def get_type_available(lines: list[str]) -> str:
    for i, line in enumerate(lines):
        if  'extension Modify' in line and '@available' in lines[i-1]:
            return lines[i-1]
    return None

def get_available(lines: list[str], func_index: int) -> str:
    current_index = copy.copy(func_index)
    while current_index > 0:
        line = lines[current_index - 1]
        if '    @available' in line:
            return line
        if line == '':
            break
        current_index -= 1
    return None

def get_func(lines: list[str], func_index: int) -> list[str]:
    index = copy.copy(func_index)
    while index > 0:
        line = lines[index - 1]
        if not '' == line:
            index -= 1
            break
    return lines[index : func_index + 4]

def find(text: str, lines: list[str]) -> int:
    for i, line in enumerate(lines):
        if line == text:
            return i
    return -1

def save(text: str, path: str):
    f = open(path, 'w')
    f.write(text)
    f.close()

def generate(type: str):
    global header
    ios_path = get_path(type, ios_files)
    mac_path = get_path(type, mac_files)

    output_path = f'{generated_dir_path}/{type}+wrap.generated.swift'

    if ios_path == None and mac_path == None:
        return

    if ios_path == None and not mac_path == None:
        save(get_text(mac_path), output_path)
        return

    if not ios_path == None and mac_path == None:
        save(get_text(ios_path), output_path)
        return

    ios_text = get_text(ios_path)
    mac_text = get_text(mac_path)

    ios_lines = ios_text.split('\n')
    mac_lines = mac_text.split('\n')

    output = copy.copy(header)

    mac_available = get_type_available(mac_lines)
    ios_available = get_type_available(ios_lines)

    if mac_available:
        output += '\n' + mac_available
    if ios_available:
        output += '\n' + ios_available

    output += '\n' + f"extension Modify.DynamicMemberWrap where T: {type} {{\n"

    ios_funcs = list(filter(lambda l: 'public func ' in l, ios_lines))
    mac_funcs = list(filter(lambda l: 'public func ' in l, mac_lines))

    common_funcs = sorted(list(set(ios_funcs) & set(mac_funcs)))
    mac_only_funcs = list(filter(lambda l: l not in ios_funcs, common_funcs))
    ios_only_funcs = list(filter(lambda l: l not in mac_funcs, common_funcs))

    for func in common_funcs:
        index = find(func, ios_lines)
        lines = get_func(ios_lines, index)

        mac_index = find(func, mac_lines)
        if not mac_index == -1:
            available = get_available(mac_lines, mac_index)
            if available:
                lines.insert(0, f'{available}')
        text = '\n'.join(lines)
        text = '\n' + text + '\n'
        output += text

    output += '\n}\n'

    output += f"""
{ios_available}
@available(macOS, unavailable)
extension Modify.DynamicMemberWrap where T: {type} {{
    """
    for func in ios_only_funcs:
        index = find(func, ios_lines)
        lines = get_func(ios_lines, index)

        text = '\n'.join(lines)
        text = '\n' + text + '\n'
        output += text

    output += '\n}\n'

    output += f"""
{mac_available}
@available(iOS, unavailable)
extension Modify.DynamicMemberWrap where T: {type} {{
"""
    for func in mac_only_funcs:
        index = find(func, mac_lines)
        lines = get_func(mac_lines, index)

        text = '\n'.join(lines)
        text = '\n' + text + '\n'
        output += text

    output += '\n}\n'

    output += '\n#endif\n'

    f = open(output_path, 'w')
    f.write(output)
    f.close()

ios_dir_path = '../Sources/DeclarativeCoreAnimation/Generated/CoreAnimation/wrap/iOS'
mac_dir_path = '../Sources/DeclarativeCoreAnimation/Generated/CoreAnimation/wrap/macOS'

ios_files = glob.glob(ios_dir_path + '/*.swift')
mac_files = glob.glob(mac_dir_path + '/*.swift')

all_type_names = list(map(lambda f: get_type_name(f), ios_files))
all_type_names += list(map(lambda f: get_type_name(f), mac_files))
all_type_names = list(set(all_type_names))
all_type_names = natsort.natsorted(all_type_names)


for type in all_type_names:
    generate(type)
